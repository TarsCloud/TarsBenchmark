// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 2.4.15.
// **********************************************************************

#ifndef __ADMIN_H_
#define __ADMIN_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
#include "tup/TarsJson.h"
using namespace std;
#include "Node.h"
#include "servant/ServantProxy.h"
#include "servant/Servant.h"


namespace bm
{
    struct TaskStat : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "bm.TaskStat";
        }
        static string MD5()
        {
            return "77dd5b1428a0f6b1a865930616e3040f";
        }
        TaskStat()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            state = 0;
            start_time = 0;
            fetch_time = 0;
            duration = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(conf, 0);
            if (state != 0)
            {
                _os.write(state, 1);
            }
            if (start_time != 0)
            {
                _os.write(start_time, 2);
            }
            if (fetch_time != 0)
            {
                _os.write(fetch_time, 3);
            }
            if (duration != 0)
            {
                _os.write(duration, 4);
            }
            if (speed_quota.size() > 0)
            {
                _os.write(speed_quota, 5);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(conf, 0, false);
            _is.read(state, 1, false);
            _is.read(start_time, 2, false);
            _is.read(fetch_time, 3, false);
            _is.read(duration, 4, false);
            _is.read(speed_quota, 5, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["conf"] = tars::JsonOutput::writeJson(conf);
            p->value["state"] = tars::JsonOutput::writeJson(state);
            p->value["start_time"] = tars::JsonOutput::writeJson(start_time);
            p->value["fetch_time"] = tars::JsonOutput::writeJson(fetch_time);
            p->value["duration"] = tars::JsonOutput::writeJson(duration);
            p->value["speed_quota"] = tars::JsonOutput::writeJson(speed_quota);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(conf,pObj->value["conf"], false);
            tars::JsonInput::readJson(state,pObj->value["state"], false);
            tars::JsonInput::readJson(start_time,pObj->value["start_time"], false);
            tars::JsonInput::readJson(fetch_time,pObj->value["fetch_time"], false);
            tars::JsonInput::readJson(duration,pObj->value["duration"], false);
            tars::JsonInput::readJson(speed_quota,pObj->value["speed_quota"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(conf,"conf");
            _ds.display(state,"state");
            _ds.display(start_time,"start_time");
            _ds.display(fetch_time,"fetch_time");
            _ds.display(duration,"duration");
            _ds.display(speed_quota,"speed_quota");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(conf, true);
            _ds.displaySimple(state, true);
            _ds.displaySimple(start_time, true);
            _ds.displaySimple(fetch_time, true);
            _ds.displaySimple(duration, true);
            _ds.displaySimple(speed_quota, false);
            return _os;
        }
    public:
        bm::TaskConf conf;
        tars::Int32 state;
        tars::Int64 start_time;
        tars::Int64 fetch_time;
        tars::Int64 duration;
        map<std::string, tars::Int32> speed_quota;
    };
    inline bool operator==(const TaskStat&l, const TaskStat&r)
    {
        return l.conf == r.conf && l.state == r.state && l.start_time == r.start_time && l.fetch_time == r.fetch_time && l.duration == r.duration && l.speed_quota == r.speed_quota;
    }
    inline bool operator!=(const TaskStat&l, const TaskStat&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TaskStat&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TaskStat&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct BenchmarkSummary : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "bm.BenchmarkSummary";
        }
        static string MD5()
        {
            return "31ba8979f12a580a24bcb677805e7455";
        }
        BenchmarkSummary()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (nodes.size() > 0)
            {
                _os.write(nodes, 0);
            }
            if (result.size() > 0)
            {
                _os.write(result, 1);
            }
            if (total_result.size() > 0)
            {
                _os.write(total_result, 2);
            }
            if (task.size() > 0)
            {
                _os.write(task, 3);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(nodes, 0, false);
            _is.read(result, 1, false);
            _is.read(total_result, 2, false);
            _is.read(task, 3, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["nodes"] = tars::JsonOutput::writeJson(nodes);
            p->value["result"] = tars::JsonOutput::writeJson(result);
            p->value["total_result"] = tars::JsonOutput::writeJson(total_result);
            p->value["task"] = tars::JsonOutput::writeJson(task);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(nodes,pObj->value["nodes"], false);
            tars::JsonInput::readJson(result,pObj->value["result"], false);
            tars::JsonInput::readJson(total_result,pObj->value["total_result"], false);
            tars::JsonInput::readJson(task,pObj->value["task"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(nodes,"nodes");
            _ds.display(result,"result");
            _ds.display(total_result,"total_result");
            _ds.display(task,"task");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(nodes, true);
            _ds.displaySimple(result, true);
            _ds.displaySimple(total_result, true);
            _ds.displaySimple(task, false);
            return _os;
        }
    public:
        map<std::string, bm::NodeStat> nodes;
        map<std::string, bm::ResultStat> result;
        map<std::string, bm::ResultStat> total_result;
        map<std::string, bm::TaskStat> task;
    };
    inline bool operator==(const BenchmarkSummary&l, const BenchmarkSummary&r)
    {
        return l.nodes == r.nodes && l.result == r.result && l.total_result == r.total_result && l.task == r.task;
    }
    inline bool operator!=(const BenchmarkSummary&l, const BenchmarkSummary&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const BenchmarkSummary&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,BenchmarkSummary&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct BenchmarkUnit : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "bm.BenchmarkUnit";
        }
        static string MD5()
        {
            return "fccf2903b7a2c5ecd59b90d0c7a7cef7";
        }
        BenchmarkUnit()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            owner = "";
            servant = "";
            rpcfunc = "";
            para_input = "";
            para_value = "";
            links = 0;
            speed = 0;
            duration = 0;
            proto = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (owner != "")
            {
                _os.write(owner, 0);
            }
            if (servant != "")
            {
                _os.write(servant, 1);
            }
            if (rpcfunc != "")
            {
                _os.write(rpcfunc, 2);
            }
            if (para_input != "")
            {
                _os.write(para_input, 3);
            }
            if (para_value != "")
            {
                _os.write(para_value, 4);
            }
            if (paralist.size() > 0)
            {
                _os.write(paralist, 5);
            }
            if (endpoints.size() > 0)
            {
                _os.write(endpoints, 6);
            }
            if (links != 0)
            {
                _os.write(links, 7);
            }
            if (speed != 0)
            {
                _os.write(speed, 8);
            }
            if (duration != 0)
            {
                _os.write(duration, 9);
            }
            if (proto != "")
            {
                _os.write(proto, 10);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(owner, 0, false);
            _is.read(servant, 1, false);
            _is.read(rpcfunc, 2, false);
            _is.read(para_input, 3, false);
            _is.read(para_value, 4, false);
            _is.read(paralist, 5, false);
            _is.read(endpoints, 6, false);
            _is.read(links, 7, false);
            _is.read(speed, 8, false);
            _is.read(duration, 9, false);
            _is.read(proto, 10, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["owner"] = tars::JsonOutput::writeJson(owner);
            p->value["servant"] = tars::JsonOutput::writeJson(servant);
            p->value["rpcfunc"] = tars::JsonOutput::writeJson(rpcfunc);
            p->value["para_input"] = tars::JsonOutput::writeJson(para_input);
            p->value["para_value"] = tars::JsonOutput::writeJson(para_value);
            p->value["paralist"] = tars::JsonOutput::writeJson(paralist);
            p->value["endpoints"] = tars::JsonOutput::writeJson(endpoints);
            p->value["links"] = tars::JsonOutput::writeJson(links);
            p->value["speed"] = tars::JsonOutput::writeJson(speed);
            p->value["duration"] = tars::JsonOutput::writeJson(duration);
            p->value["proto"] = tars::JsonOutput::writeJson(proto);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(owner,pObj->value["owner"], false);
            tars::JsonInput::readJson(servant,pObj->value["servant"], false);
            tars::JsonInput::readJson(rpcfunc,pObj->value["rpcfunc"], false);
            tars::JsonInput::readJson(para_input,pObj->value["para_input"], false);
            tars::JsonInput::readJson(para_value,pObj->value["para_value"], false);
            tars::JsonInput::readJson(paralist,pObj->value["paralist"], false);
            tars::JsonInput::readJson(endpoints,pObj->value["endpoints"], false);
            tars::JsonInput::readJson(links,pObj->value["links"], false);
            tars::JsonInput::readJson(speed,pObj->value["speed"], false);
            tars::JsonInput::readJson(duration,pObj->value["duration"], false);
            tars::JsonInput::readJson(proto,pObj->value["proto"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(owner,"owner");
            _ds.display(servant,"servant");
            _ds.display(rpcfunc,"rpcfunc");
            _ds.display(para_input,"para_input");
            _ds.display(para_value,"para_value");
            _ds.display(paralist,"paralist");
            _ds.display(endpoints,"endpoints");
            _ds.display(links,"links");
            _ds.display(speed,"speed");
            _ds.display(duration,"duration");
            _ds.display(proto,"proto");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(owner, true);
            _ds.displaySimple(servant, true);
            _ds.displaySimple(rpcfunc, true);
            _ds.displaySimple(para_input, true);
            _ds.displaySimple(para_value, true);
            _ds.displaySimple(paralist, true);
            _ds.displaySimple(endpoints, true);
            _ds.displaySimple(links, true);
            _ds.displaySimple(speed, true);
            _ds.displaySimple(duration, true);
            _ds.displaySimple(proto, false);
            return _os;
        }
    public:
        std::string owner;
        std::string servant;
        std::string rpcfunc;
        std::string para_input;
        std::string para_value;
        vector<std::string> paralist;
        vector<std::string> endpoints;
        tars::Int32 links;
        tars::Int32 speed;
        tars::Int32 duration;
        std::string proto;
    };
    inline bool operator==(const BenchmarkUnit&l, const BenchmarkUnit&r)
    {
        return l.owner == r.owner && l.servant == r.servant && l.rpcfunc == r.rpcfunc && l.para_input == r.para_input && l.para_value == r.para_value && l.paralist == r.paralist && l.endpoints == r.endpoints && l.links == r.links && l.speed == r.speed && l.duration == r.duration && l.proto == r.proto;
    }
    inline bool operator!=(const BenchmarkUnit&l, const BenchmarkUnit&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const BenchmarkUnit&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,BenchmarkUnit&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }
    inline bool operator<(const BenchmarkUnit&l, const BenchmarkUnit&r)
    {
        if(l.servant != r.servant)  return (l.servant < r.servant);
        if(l.rpcfunc != r.rpcfunc)  return (l.rpcfunc < r.rpcfunc);
        return false;
    }
    inline bool operator<=(const BenchmarkUnit&l, const BenchmarkUnit&r)
    {
        return !(r < l);
    }
    inline bool operator>(const BenchmarkUnit&l, const BenchmarkUnit&r)
    {
        return r < l;
    }
    inline bool operator>=(const BenchmarkUnit&l, const BenchmarkUnit&r)
    {
        return !(l < r);
    }


    /* callback of async proxy for client */
    class AdminPrxCallback: public tars::ServantProxyCallback
    {
    public:
        virtual ~AdminPrxCallback(){}
        virtual void callback_query(tars::Int32 ret,  const bm::ResultStat& stat)
        { throw std::runtime_error("callback_query() override incorrect."); }
        virtual void callback_query_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_query_exception() override incorrect."); }

        virtual void callback_shutdown(tars::Int32 ret,  const bm::ResultStat& stat)
        { throw std::runtime_error("callback_shutdown() override incorrect."); }
        virtual void callback_shutdown_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_shutdown_exception() override incorrect."); }

        virtual void callback_startup(tars::Int32 ret)
        { throw std::runtime_error("callback_startup() override incorrect."); }
        virtual void callback_startup_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_startup_exception() override incorrect."); }

        virtual void callback_test(tars::Int32 ret,  const std::string& rsp,  const std::string& errmsg)
        { throw std::runtime_error("callback_test() override incorrect."); }
        virtual void callback_test_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_test_exception() override incorrect."); }

    public:
        virtual const map<std::string, std::string> & getResponseContext() const
        {
            CallbackThreadData * pCbtd = CallbackThreadData::getData();
            assert(pCbtd != NULL);

            if(!pCbtd->getContextValid())
            {
                throw TC_Exception("cann't get response context");
            }
            return pCbtd->getResponseContext();
        }

    public:
        virtual int onDispatch(tars::ReqMessagePtr msg)
        {
            static ::std::string __Admin_all[]=
            {
                "query",
                "shutdown",
                "startup",
                "test"
            };
            pair<string*, string*> r = equal_range(__Admin_all, __Admin_all+4, string(msg->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __Admin_all)
            {
                case 0:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_query_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    bm::ResultStat stat;
                    _is.read(stat, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_query(_ret, stat);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_shutdown_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    bm::ResultStat stat;
                    _is.read(stat, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_shutdown(_ret, stat);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_startup_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_startup(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_test_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string rsp;
                    _is.read(rsp, 2, true);
                    std::string errmsg;
                    _is.read(errmsg, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_test(_ret, rsp, errmsg);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    };
    typedef tars::TC_AutoPtr<AdminPrxCallback> AdminPrxCallbackPtr;

    /* callback of coroutine async proxy for client */
    class AdminCoroPrxCallback: public AdminPrxCallback
    {
    public:
        virtual ~AdminCoroPrxCallback(){}
    public:
        virtual const map<std::string, std::string> & getResponseContext() const { return _mRspContext; }

        virtual void setResponseContext(const map<std::string, std::string> &mContext) { _mRspContext = mContext; }

    public:
        int onDispatch(tars::ReqMessagePtr msg)
        {
            static ::std::string __Admin_all[]=
            {
                "query",
                "shutdown",
                "startup",
                "test"
            };

            pair<string*, string*> r = equal_range(__Admin_all, __Admin_all+4, string(msg->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __Admin_all)
            {
                case 0:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_query_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        bm::ResultStat stat;
                        _is.read(stat, 2, true);
                        setResponseContext(msg->response->context);

                        callback_query(_ret, stat);

                    }
                    catch(std::exception &ex)
                    {
                        callback_query_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_query_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_shutdown_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        bm::ResultStat stat;
                        _is.read(stat, 2, true);
                        setResponseContext(msg->response->context);

                        callback_shutdown(_ret, stat);

                    }
                    catch(std::exception &ex)
                    {
                        callback_shutdown_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_shutdown_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_startup_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(msg->response->context);

                        callback_startup(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_startup_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_startup_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_test_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string rsp;
                        _is.read(rsp, 2, true);
                        std::string errmsg;
                        _is.read(errmsg, 3, true);
                        setResponseContext(msg->response->context);

                        callback_test(_ret, rsp, errmsg);

                    }
                    catch(std::exception &ex)
                    {
                        callback_test_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_test_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    protected:
        map<std::string, std::string> _mRspContext;
    };
    typedef tars::TC_AutoPtr<AdminCoroPrxCallback> AdminCoroPrxCallbackPtr;

    /* proxy for client */
    class AdminProxy : public tars::ServantProxy
    {
    public:
        typedef map<string, string> TARS_CONTEXT;
        tars::Int32 query(const bm::BenchmarkUnit & req,bm::ResultStat &stat,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            _os.write(stat, 2);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"query", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(stat, 2, true);
            return _ret;
        }

        void async_query(AdminPrxCallbackPtr callback,const bm::BenchmarkUnit &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"query", _os, context, _mStatus, callback);
        }
        
        void coro_query(AdminCoroPrxCallbackPtr callback,const bm::BenchmarkUnit &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"query", _os, context, _mStatus, callback, true);
        }

        tars::Int32 shutdown(const bm::BenchmarkUnit & req,bm::ResultStat &stat,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            _os.write(stat, 2);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"shutdown", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(stat, 2, true);
            return _ret;
        }

        void async_shutdown(AdminPrxCallbackPtr callback,const bm::BenchmarkUnit &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"shutdown", _os, context, _mStatus, callback);
        }
        
        void coro_shutdown(AdminCoroPrxCallbackPtr callback,const bm::BenchmarkUnit &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"shutdown", _os, context, _mStatus, callback, true);
        }

        tars::Int32 startup(const bm::BenchmarkUnit & req,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"startup", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_startup(AdminPrxCallbackPtr callback,const bm::BenchmarkUnit &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"startup", _os, context, _mStatus, callback);
        }
        
        void coro_startup(AdminCoroPrxCallbackPtr callback,const bm::BenchmarkUnit &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"startup", _os, context, _mStatus, callback, true);
        }

        tars::Int32 test(const bm::BenchmarkUnit & req,std::string &rsp,std::string &errmsg,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            _os.write(rsp, 2);
            _os.write(errmsg, 3);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"test", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(rsp, 2, true);
            _is.read(errmsg, 3, true);
            return _ret;
        }

        void async_test(AdminPrxCallbackPtr callback,const bm::BenchmarkUnit &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"test", _os, context, _mStatus, callback);
        }
        
        void coro_test(AdminCoroPrxCallbackPtr callback,const bm::BenchmarkUnit &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"test", _os, context, _mStatus, callback, true);
        }

        AdminProxy* tars_hash(int64_t key)
        {
            return (AdminProxy*)ServantProxy::tars_hash(key);
        }

        AdminProxy* tars_consistent_hash(int64_t key)
        {
            return (AdminProxy*)ServantProxy::tars_consistent_hash(key);
        }

        AdminProxy* tars_set_timeout(int msecond)
        {
            return (AdminProxy*)ServantProxy::tars_set_timeout(msecond);
        }

        static const char* tars_prxname() { return "AdminProxy"; }
    };
    typedef tars::TC_AutoPtr<AdminProxy> AdminPrx;

    /* servant for server */
    class Admin : public tars::Servant
    {
    public:
        virtual ~Admin(){}
        virtual tars::Int32 query(const bm::BenchmarkUnit & req,bm::ResultStat &stat,tars::TarsCurrentPtr current) = 0;
        static void async_response_query(tars::TarsCurrentPtr current, tars::Int32 _ret, const bm::ResultStat &stat)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("tars_ret", _ret);
                tarsAttr.put("stat", stat);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["stat"] = tars::JsonOutput::writeJson(stat);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(stat, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 shutdown(const bm::BenchmarkUnit & req,bm::ResultStat &stat,tars::TarsCurrentPtr current) = 0;
        static void async_response_shutdown(tars::TarsCurrentPtr current, tars::Int32 _ret, const bm::ResultStat &stat)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("tars_ret", _ret);
                tarsAttr.put("stat", stat);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["stat"] = tars::JsonOutput::writeJson(stat);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(stat, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 startup(const bm::BenchmarkUnit & req,tars::TarsCurrentPtr current) = 0;
        static void async_response_startup(tars::TarsCurrentPtr current, tars::Int32 _ret)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 test(const bm::BenchmarkUnit & req,std::string &rsp,std::string &errmsg,tars::TarsCurrentPtr current) = 0;
        static void async_response_test(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &rsp, const std::string &errmsg)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("tars_ret", _ret);
                tarsAttr.put("rsp", rsp);
                tarsAttr.put("errmsg", errmsg);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["rsp"] = tars::JsonOutput::writeJson(rsp);
                _p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(rsp, 2);

                _os.write(errmsg, 3);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

    public:
        int onDispatch(tars::TarsCurrentPtr _current, vector<char> &_sResponseBuffer)
        {
            static ::std::string __bm__Admin_all[]=
            {
                "query",
                "shutdown",
                "startup",
                "test"
            };

            pair<string*, string*> r = equal_range(__bm__Admin_all, __bm__Admin_all+4, _current->getFuncName());
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __bm__Admin_all)
            {
                case 0:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    bm::BenchmarkUnit req;
                    bm::ResultStat stat;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("req", req);
                        tarsAttr.getByDefault("stat", stat, stat);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(req, _jsonPtr->value["req"], true);
                        tars::JsonInput::readJson(stat, _jsonPtr->value["stat"], false);
                    }
                    else
                    {
                        _is.read(req, 1, true);
                        _is.read(stat, 2, false);
                    }
                    tars::Int32 _ret = query(req,stat, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("tars_ret", _ret);
                            tarsAttr.put("stat", stat);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["stat"] = tars::JsonOutput::writeJson(stat);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(stat, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    bm::BenchmarkUnit req;
                    bm::ResultStat stat;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("req", req);
                        tarsAttr.getByDefault("stat", stat, stat);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(req, _jsonPtr->value["req"], true);
                        tars::JsonInput::readJson(stat, _jsonPtr->value["stat"], false);
                    }
                    else
                    {
                        _is.read(req, 1, true);
                        _is.read(stat, 2, false);
                    }
                    tars::Int32 _ret = shutdown(req,stat, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("tars_ret", _ret);
                            tarsAttr.put("stat", stat);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["stat"] = tars::JsonOutput::writeJson(stat);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(stat, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    bm::BenchmarkUnit req;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("req", req);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(req, _jsonPtr->value["req"], true);
                    }
                    else
                    {
                        _is.read(req, 1, true);
                    }
                    tars::Int32 _ret = startup(req, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("tars_ret", _ret);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    bm::BenchmarkUnit req;
                    std::string rsp;
                    std::string errmsg;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("req", req);
                        tarsAttr.getByDefault("rsp", rsp, rsp);
                        tarsAttr.getByDefault("errmsg", errmsg, errmsg);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(req, _jsonPtr->value["req"], true);
                        tars::JsonInput::readJson(rsp, _jsonPtr->value["rsp"], false);
                        tars::JsonInput::readJson(errmsg, _jsonPtr->value["errmsg"], false);
                    }
                    else
                    {
                        _is.read(req, 1, true);
                        _is.read(rsp, 2, false);
                        _is.read(errmsg, 3, false);
                    }
                    tars::Int32 _ret = test(req,rsp,errmsg, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("tars_ret", _ret);
                            tarsAttr.put("rsp", rsp);
                            tarsAttr.put("errmsg", errmsg);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["rsp"] = tars::JsonOutput::writeJson(rsp);
                            _p->value["errmsg"] = tars::JsonOutput::writeJson(errmsg);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(rsp, 2);
                            _os.write(errmsg, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }
    };


}



#endif
