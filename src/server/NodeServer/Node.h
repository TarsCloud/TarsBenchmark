// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 2.4.15.
// **********************************************************************

#ifndef __NODE_H_
#define __NODE_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
#include "tup/TarsJson.h"
using namespace std;
#include "servant/ServantProxy.h"
#include "servant/Servant.h"


namespace bm
{
    enum TaskState
    {
        TS_IDLE = 0,
        TS_RUNNING = 1,
        TS_FINISHED = 2,
    };
    inline string etos(const TaskState & e)
    {
        switch(e)
        {
            case TS_IDLE: return "TS_IDLE";
            case TS_RUNNING: return "TS_RUNNING";
            case TS_FINISHED: return "TS_FINISHED";
            default: return "";
        }
    }
    inline int stoe(const string & s, TaskState & e)
    {
        if(s == "TS_IDLE")  { e=TS_IDLE; return 0;}
        if(s == "TS_RUNNING")  { e=TS_RUNNING; return 0;}
        if(s == "TS_FINISHED")  { e=TS_FINISHED; return 0;}

        return -1;
    }

    struct ResultStat : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "bm.ResultStat";
        }
        static string MD5()
        {
            return "9be36095125e488ca17a400e211d3a4e";
        }
        ResultStat()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            time_stamp = 0;
            total_request = 0;
            succ_request = 0;
            fail_request = 0;
            max_time = 0;
            min_time = 1000;
            total_time = 0;
            p999_time = 0;
            p99_time = 0;
            p90_time = 0;
            send_bytes = 0;
            recv_bytes = 0;
            avg_speed = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (time_stamp != 0)
            {
                _os.write(time_stamp, 0);
            }
            if (ret_map.size() > 0)
            {
                _os.write(ret_map, 1);
            }
            if (cost_map.size() > 0)
            {
                _os.write(cost_map, 2);
            }
            if (total_request != 0)
            {
                _os.write(total_request, 3);
            }
            if (succ_request != 0)
            {
                _os.write(succ_request, 4);
            }
            if (fail_request != 0)
            {
                _os.write(fail_request, 5);
            }
            if (max_time != 0)
            {
                _os.write(max_time, 6);
            }
            if (min_time != 1000)
            {
                _os.write(min_time, 7);
            }
            if (total_time != 0)
            {
                _os.write(total_time, 8);
            }
            if (p999_time != 0)
            {
                _os.write(p999_time, 9);
            }
            if (p99_time != 0)
            {
                _os.write(p99_time, 10);
            }
            if (p90_time != 0)
            {
                _os.write(p90_time, 11);
            }
            if (send_bytes != 0)
            {
                _os.write(send_bytes, 12);
            }
            if (recv_bytes != 0)
            {
                _os.write(recv_bytes, 13);
            }
            if (avg_speed != 0)
            {
                _os.write(avg_speed, 14);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(time_stamp, 0, false);
            _is.read(ret_map, 1, false);
            _is.read(cost_map, 2, false);
            _is.read(total_request, 3, false);
            _is.read(succ_request, 4, false);
            _is.read(fail_request, 5, false);
            _is.read(max_time, 6, false);
            _is.read(min_time, 7, false);
            _is.read(total_time, 8, false);
            _is.read(p999_time, 9, false);
            _is.read(p99_time, 10, false);
            _is.read(p90_time, 11, false);
            _is.read(send_bytes, 12, false);
            _is.read(recv_bytes, 13, false);
            _is.read(avg_speed, 14, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["time_stamp"] = tars::JsonOutput::writeJson(time_stamp);
            p->value["ret_map"] = tars::JsonOutput::writeJson(ret_map);
            p->value["cost_map"] = tars::JsonOutput::writeJson(cost_map);
            p->value["total_request"] = tars::JsonOutput::writeJson(total_request);
            p->value["succ_request"] = tars::JsonOutput::writeJson(succ_request);
            p->value["fail_request"] = tars::JsonOutput::writeJson(fail_request);
            p->value["max_time"] = tars::JsonOutput::writeJson(max_time);
            p->value["min_time"] = tars::JsonOutput::writeJson(min_time);
            p->value["total_time"] = tars::JsonOutput::writeJson(total_time);
            p->value["p999_time"] = tars::JsonOutput::writeJson(p999_time);
            p->value["p99_time"] = tars::JsonOutput::writeJson(p99_time);
            p->value["p90_time"] = tars::JsonOutput::writeJson(p90_time);
            p->value["send_bytes"] = tars::JsonOutput::writeJson(send_bytes);
            p->value["recv_bytes"] = tars::JsonOutput::writeJson(recv_bytes);
            p->value["avg_speed"] = tars::JsonOutput::writeJson(avg_speed);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(time_stamp,pObj->value["time_stamp"], false);
            tars::JsonInput::readJson(ret_map,pObj->value["ret_map"], false);
            tars::JsonInput::readJson(cost_map,pObj->value["cost_map"], false);
            tars::JsonInput::readJson(total_request,pObj->value["total_request"], false);
            tars::JsonInput::readJson(succ_request,pObj->value["succ_request"], false);
            tars::JsonInput::readJson(fail_request,pObj->value["fail_request"], false);
            tars::JsonInput::readJson(max_time,pObj->value["max_time"], false);
            tars::JsonInput::readJson(min_time,pObj->value["min_time"], false);
            tars::JsonInput::readJson(total_time,pObj->value["total_time"], false);
            tars::JsonInput::readJson(p999_time,pObj->value["p999_time"], false);
            tars::JsonInput::readJson(p99_time,pObj->value["p99_time"], false);
            tars::JsonInput::readJson(p90_time,pObj->value["p90_time"], false);
            tars::JsonInput::readJson(send_bytes,pObj->value["send_bytes"], false);
            tars::JsonInput::readJson(recv_bytes,pObj->value["recv_bytes"], false);
            tars::JsonInput::readJson(avg_speed,pObj->value["avg_speed"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(time_stamp,"time_stamp");
            _ds.display(ret_map,"ret_map");
            _ds.display(cost_map,"cost_map");
            _ds.display(total_request,"total_request");
            _ds.display(succ_request,"succ_request");
            _ds.display(fail_request,"fail_request");
            _ds.display(max_time,"max_time");
            _ds.display(min_time,"min_time");
            _ds.display(total_time,"total_time");
            _ds.display(p999_time,"p999_time");
            _ds.display(p99_time,"p99_time");
            _ds.display(p90_time,"p90_time");
            _ds.display(send_bytes,"send_bytes");
            _ds.display(recv_bytes,"recv_bytes");
            _ds.display(avg_speed,"avg_speed");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(time_stamp, true);
            _ds.displaySimple(ret_map, true);
            _ds.displaySimple(cost_map, true);
            _ds.displaySimple(total_request, true);
            _ds.displaySimple(succ_request, true);
            _ds.displaySimple(fail_request, true);
            _ds.displaySimple(max_time, true);
            _ds.displaySimple(min_time, true);
            _ds.displaySimple(total_time, true);
            _ds.displaySimple(p999_time, true);
            _ds.displaySimple(p99_time, true);
            _ds.displaySimple(p90_time, true);
            _ds.displaySimple(send_bytes, true);
            _ds.displaySimple(recv_bytes, true);
            _ds.displaySimple(avg_speed, false);
            return _os;
        }
    public:
        tars::Int64 time_stamp;
        map<tars::Int32, tars::Int64> ret_map;
        map<tars::Int32, tars::Int64> cost_map;
        tars::Int64 total_request;
        tars::Int64 succ_request;
        tars::Int64 fail_request;
        tars::Double max_time;
        tars::Double min_time;
        tars::Double total_time;
        tars::Double p999_time;
        tars::Double p99_time;
        tars::Double p90_time;
        tars::Int64 send_bytes;
        tars::Int64 recv_bytes;
        tars::Int32 avg_speed;
    };
    inline bool operator==(const ResultStat&l, const ResultStat&r)
    {
        return l.time_stamp == r.time_stamp && l.ret_map == r.ret_map && l.cost_map == r.cost_map && l.total_request == r.total_request && l.succ_request == r.succ_request && l.fail_request == r.fail_request && l.max_time == r.max_time && l.min_time == r.min_time && l.total_time == r.total_time && l.p999_time == r.p999_time && l.p99_time == r.p99_time && l.p90_time == r.p90_time && l.send_bytes == r.send_bytes && l.recv_bytes == r.recv_bytes && l.avg_speed == r.avg_speed;
    }
    inline bool operator!=(const ResultStat&l, const ResultStat&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ResultStat&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ResultStat&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct ExecItem : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "bm.ExecItem";
        }
        static string MD5()
        {
            return "800d2604cc23f3fbe2d93b27a7027a6b";
        }
        ExecItem()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            proto = "";
            service = "";
            threads = 0;
            links = 0;
            speed = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (proto != "")
            {
                _os.write(proto, 0);
            }
            if (service != "")
            {
                _os.write(service, 1);
            }
            if (threads != 0)
            {
                _os.write(threads, 2);
            }
            if (links != 0)
            {
                _os.write(links, 3);
            }
            if (speed != 0)
            {
                _os.write(speed, 4);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(proto, 0, false);
            _is.read(service, 1, false);
            _is.read(threads, 2, false);
            _is.read(links, 3, false);
            _is.read(speed, 4, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["proto"] = tars::JsonOutput::writeJson(proto);
            p->value["service"] = tars::JsonOutput::writeJson(service);
            p->value["threads"] = tars::JsonOutput::writeJson(threads);
            p->value["links"] = tars::JsonOutput::writeJson(links);
            p->value["speed"] = tars::JsonOutput::writeJson(speed);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(proto,pObj->value["proto"], false);
            tars::JsonInput::readJson(service,pObj->value["service"], false);
            tars::JsonInput::readJson(threads,pObj->value["threads"], false);
            tars::JsonInput::readJson(links,pObj->value["links"], false);
            tars::JsonInput::readJson(speed,pObj->value["speed"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(proto,"proto");
            _ds.display(service,"service");
            _ds.display(threads,"threads");
            _ds.display(links,"links");
            _ds.display(speed,"speed");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(proto, true);
            _ds.displaySimple(service, true);
            _ds.displaySimple(threads, true);
            _ds.displaySimple(links, true);
            _ds.displaySimple(speed, false);
            return _os;
        }
    public:
        std::string proto;
        std::string service;
        tars::Int32 threads;
        tars::Int32 links;
        tars::Int32 speed;
    };
    inline bool operator==(const ExecItem&l, const ExecItem&r)
    {
        return l.proto == r.proto && l.service == r.service && l.threads == r.threads && l.links == r.links && l.speed == r.speed;
    }
    inline bool operator!=(const ExecItem&l, const ExecItem&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const ExecItem&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,ExecItem&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct NodeStat : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "bm.NodeStat";
        }
        static string MD5()
        {
            return "de158a7597b3a4b10df04acb71e9151b";
        }
        NodeStat()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            ipaddr = "";
            max_speed = 0;
            max_threads = 0;
            left_speed = 0;
            left_threads = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (ipaddr != "")
            {
                _os.write(ipaddr, 0);
            }
            if (max_speed != 0)
            {
                _os.write(max_speed, 1);
            }
            if (max_threads != 0)
            {
                _os.write(max_threads, 2);
            }
            if (left_speed != 0)
            {
                _os.write(left_speed, 3);
            }
            if (left_threads != 0)
            {
                _os.write(left_threads, 4);
            }
            if (executors.size() > 0)
            {
                _os.write(executors, 5);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ipaddr, 0, false);
            _is.read(max_speed, 1, false);
            _is.read(max_threads, 2, false);
            _is.read(left_speed, 3, false);
            _is.read(left_threads, 4, false);
            _is.read(executors, 5, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["ipaddr"] = tars::JsonOutput::writeJson(ipaddr);
            p->value["max_speed"] = tars::JsonOutput::writeJson(max_speed);
            p->value["max_threads"] = tars::JsonOutput::writeJson(max_threads);
            p->value["left_speed"] = tars::JsonOutput::writeJson(left_speed);
            p->value["left_threads"] = tars::JsonOutput::writeJson(left_threads);
            p->value["executors"] = tars::JsonOutput::writeJson(executors);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(ipaddr,pObj->value["ipaddr"], false);
            tars::JsonInput::readJson(max_speed,pObj->value["max_speed"], false);
            tars::JsonInput::readJson(max_threads,pObj->value["max_threads"], false);
            tars::JsonInput::readJson(left_speed,pObj->value["left_speed"], false);
            tars::JsonInput::readJson(left_threads,pObj->value["left_threads"], false);
            tars::JsonInput::readJson(executors,pObj->value["executors"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(ipaddr,"ipaddr");
            _ds.display(max_speed,"max_speed");
            _ds.display(max_threads,"max_threads");
            _ds.display(left_speed,"left_speed");
            _ds.display(left_threads,"left_threads");
            _ds.display(executors,"executors");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(ipaddr, true);
            _ds.displaySimple(max_speed, true);
            _ds.displaySimple(max_threads, true);
            _ds.displaySimple(left_speed, true);
            _ds.displaySimple(left_threads, true);
            _ds.displaySimple(executors, false);
            return _os;
        }
    public:
        std::string ipaddr;
        tars::Int32 max_speed;
        tars::Int32 max_threads;
        tars::Int32 left_speed;
        tars::Int32 left_threads;
        vector<bm::ExecItem> executors;
    };
    inline bool operator==(const NodeStat&l, const NodeStat&r)
    {
        return l.ipaddr == r.ipaddr && l.max_speed == r.max_speed && l.max_threads == r.max_threads && l.left_speed == r.left_speed && l.left_threads == r.left_threads && l.executors == r.executors;
    }
    inline bool operator!=(const NodeStat&l, const NodeStat&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const NodeStat&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,NodeStat&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }
    inline bool operator<(const NodeStat&l, const NodeStat&r)
    {
        if(l.ipaddr != r.ipaddr)  return (l.ipaddr < r.ipaddr);
        return false;
    }
    inline bool operator<=(const NodeStat&l, const NodeStat&r)
    {
        return !(r < l);
    }
    inline bool operator>(const NodeStat&l, const NodeStat&r)
    {
        return r < l;
    }
    inline bool operator>=(const NodeStat&l, const NodeStat&r)
    {
        return !(l < r);
    }

    struct QueryRsp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "bm.QueryRsp";
        }
        static string MD5()
        {
            return "8606b0c5855e11f4fb00ab6fcc2d2fe7";
        }
        QueryRsp()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            ipaddr = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(stat, 0);
            if (ipaddr != "")
            {
                _os.write(ipaddr, 1);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(stat, 0, false);
            _is.read(ipaddr, 1, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["stat"] = tars::JsonOutput::writeJson(stat);
            p->value["ipaddr"] = tars::JsonOutput::writeJson(ipaddr);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(stat,pObj->value["stat"], false);
            tars::JsonInput::readJson(ipaddr,pObj->value["ipaddr"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(stat,"stat");
            _ds.display(ipaddr,"ipaddr");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(stat, true);
            _ds.displaySimple(ipaddr, false);
            return _os;
        }
    public:
        bm::ResultStat stat;
        std::string ipaddr;
    };
    inline bool operator==(const QueryRsp&l, const QueryRsp&r)
    {
        return l.stat == r.stat && l.ipaddr == r.ipaddr;
    }
    inline bool operator!=(const QueryRsp&l, const QueryRsp&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const QueryRsp&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,QueryRsp&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct TaskConf : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "bm.TaskConf";
        }
        static string MD5()
        {
            return "d3b8f012afcaa18d876f61c768f713bd";
        }
        TaskConf()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            proto = "";
            service = "";
            links = 0;
            speed = 0;
            runflag = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (proto != "")
            {
                _os.write(proto, 0);
            }
            if (service != "")
            {
                _os.write(service, 1);
            }
            if (paralist.size() > 0)
            {
                _os.write(paralist, 2);
            }
            if (endpoints.size() > 0)
            {
                _os.write(endpoints, 3);
            }
            if (links != 0)
            {
                _os.write(links, 4);
            }
            if (speed != 0)
            {
                _os.write(speed, 5);
            }
            if (runflag != 0)
            {
                _os.write(runflag, 6);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(proto, 0, false);
            _is.read(service, 1, false);
            _is.read(paralist, 2, false);
            _is.read(endpoints, 3, false);
            _is.read(links, 4, false);
            _is.read(speed, 5, false);
            _is.read(runflag, 6, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["proto"] = tars::JsonOutput::writeJson(proto);
            p->value["service"] = tars::JsonOutput::writeJson(service);
            p->value["paralist"] = tars::JsonOutput::writeJson(paralist);
            p->value["endpoints"] = tars::JsonOutput::writeJson(endpoints);
            p->value["links"] = tars::JsonOutput::writeJson(links);
            p->value["speed"] = tars::JsonOutput::writeJson(speed);
            p->value["runflag"] = tars::JsonOutput::writeJson(runflag);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(proto,pObj->value["proto"], false);
            tars::JsonInput::readJson(service,pObj->value["service"], false);
            tars::JsonInput::readJson(paralist,pObj->value["paralist"], false);
            tars::JsonInput::readJson(endpoints,pObj->value["endpoints"], false);
            tars::JsonInput::readJson(links,pObj->value["links"], false);
            tars::JsonInput::readJson(speed,pObj->value["speed"], false);
            tars::JsonInput::readJson(runflag,pObj->value["runflag"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(proto,"proto");
            _ds.display(service,"service");
            _ds.display(paralist,"paralist");
            _ds.display(endpoints,"endpoints");
            _ds.display(links,"links");
            _ds.display(speed,"speed");
            _ds.display(runflag,"runflag");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(proto, true);
            _ds.displaySimple(service, true);
            _ds.displaySimple(paralist, true);
            _ds.displaySimple(endpoints, true);
            _ds.displaySimple(links, true);
            _ds.displaySimple(speed, true);
            _ds.displaySimple(runflag, false);
            return _os;
        }
    public:
        std::string proto;
        std::string service;
        vector<std::string> paralist;
        vector<std::string> endpoints;
        tars::Int32 links;
        tars::Int32 speed;
        tars::Int32 runflag;
    };
    inline bool operator==(const TaskConf&l, const TaskConf&r)
    {
        return l.proto == r.proto && l.service == r.service && l.paralist == r.paralist && l.endpoints == r.endpoints && l.links == r.links && l.speed == r.speed && l.runflag == r.runflag;
    }
    inline bool operator!=(const TaskConf&l, const TaskConf&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const TaskConf&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,TaskConf&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }
    inline bool operator<(const TaskConf&l, const TaskConf&r)
    {
        if(l.proto != r.proto)  return (l.proto < r.proto);
        if(l.service != r.service)  return (l.service < r.service);
        return false;
    }
    inline bool operator<=(const TaskConf&l, const TaskConf&r)
    {
        return !(r < l);
    }
    inline bool operator>(const TaskConf&l, const TaskConf&r)
    {
        return r < l;
    }
    inline bool operator>=(const TaskConf&l, const TaskConf&r)
    {
        return !(l < r);
    }


    /* callback of async proxy for client */
    class NodePrxCallback: public tars::ServantProxyCallback
    {
    public:
        virtual ~NodePrxCallback(){}
        virtual void callback_capacity(tars::Int32 ret,  const bm::NodeStat& stats)
        { throw std::runtime_error("callback_capacity() override incorrect."); }
        virtual void callback_capacity_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_capacity_exception() override incorrect."); }

        virtual void callback_query(tars::Int32 ret,  const bm::QueryRsp& rsp)
        { throw std::runtime_error("callback_query() override incorrect."); }
        virtual void callback_query_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_query_exception() override incorrect."); }

        virtual void callback_shutdown(tars::Int32 ret,  const bm::QueryRsp& rsp)
        { throw std::runtime_error("callback_shutdown() override incorrect."); }
        virtual void callback_shutdown_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_shutdown_exception() override incorrect."); }

        virtual void callback_startup(tars::Int32 ret)
        { throw std::runtime_error("callback_startup() override incorrect."); }
        virtual void callback_startup_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_startup_exception() override incorrect."); }

    public:
        virtual const map<std::string, std::string> & getResponseContext() const
        {
            CallbackThreadData * pCbtd = CallbackThreadData::getData();
            assert(pCbtd != NULL);

            if(!pCbtd->getContextValid())
            {
                throw TC_Exception("cann't get response context");
            }
            return pCbtd->getResponseContext();
        }

    public:
        virtual int onDispatch(tars::ReqMessagePtr msg)
        {
            static ::std::string __Node_all[]=
            {
                "capacity",
                "query",
                "shutdown",
                "startup"
            };
            pair<string*, string*> r = equal_range(__Node_all, __Node_all+4, string(msg->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __Node_all)
            {
                case 0:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_capacity_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    bm::NodeStat stats;
                    _is.read(stats, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_capacity(_ret, stats);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_query_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    bm::QueryRsp rsp;
                    _is.read(rsp, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_query(_ret, rsp);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_shutdown_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    bm::QueryRsp rsp;
                    _is.read(rsp, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_shutdown(_ret, rsp);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_startup_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_startup(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    };
    typedef tars::TC_AutoPtr<NodePrxCallback> NodePrxCallbackPtr;

    /* callback of coroutine async proxy for client */
    class NodeCoroPrxCallback: public NodePrxCallback
    {
    public:
        virtual ~NodeCoroPrxCallback(){}
    public:
        virtual const map<std::string, std::string> & getResponseContext() const { return _mRspContext; }

        virtual void setResponseContext(const map<std::string, std::string> &mContext) { _mRspContext = mContext; }

    public:
        int onDispatch(tars::ReqMessagePtr msg)
        {
            static ::std::string __Node_all[]=
            {
                "capacity",
                "query",
                "shutdown",
                "startup"
            };

            pair<string*, string*> r = equal_range(__Node_all, __Node_all+4, string(msg->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __Node_all)
            {
                case 0:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_capacity_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        bm::NodeStat stats;
                        _is.read(stats, 1, true);
                        setResponseContext(msg->response->context);

                        callback_capacity(_ret, stats);

                    }
                    catch(std::exception &ex)
                    {
                        callback_capacity_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_capacity_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_query_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        bm::QueryRsp rsp;
                        _is.read(rsp, 2, true);
                        setResponseContext(msg->response->context);

                        callback_query(_ret, rsp);

                    }
                    catch(std::exception &ex)
                    {
                        callback_query_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_query_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_shutdown_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        bm::QueryRsp rsp;
                        _is.read(rsp, 2, true);
                        setResponseContext(msg->response->context);

                        callback_shutdown(_ret, rsp);

                    }
                    catch(std::exception &ex)
                    {
                        callback_shutdown_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_shutdown_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response->iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_startup_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(msg->response->context);

                        callback_startup(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_startup_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_startup_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    protected:
        map<std::string, std::string> _mRspContext;
    };
    typedef tars::TC_AutoPtr<NodeCoroPrxCallback> NodeCoroPrxCallbackPtr;

    /* proxy for client */
    class NodeProxy : public tars::ServantProxy
    {
    public:
        typedef map<string, string> TARS_CONTEXT;
        tars::Int32 capacity(bm::NodeStat &stats,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(stats, 1);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"capacity", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(stats, 1, true);
            return _ret;
        }

        void async_capacity(NodePrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"capacity", _os, context, _mStatus, callback);
        }
        
        void coro_capacity(NodeCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"capacity", _os, context, _mStatus, callback, true);
        }

        tars::Int32 query(const bm::TaskConf & req,bm::QueryRsp &rsp,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            _os.write(rsp, 2);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"query", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(rsp, 2, true);
            return _ret;
        }

        void async_query(NodePrxCallbackPtr callback,const bm::TaskConf &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"query", _os, context, _mStatus, callback);
        }
        
        void coro_query(NodeCoroPrxCallbackPtr callback,const bm::TaskConf &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"query", _os, context, _mStatus, callback, true);
        }

        tars::Int32 shutdown(const bm::TaskConf & req,bm::QueryRsp &rsp,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            _os.write(rsp, 2);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"shutdown", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(rsp, 2, true);
            return _ret;
        }

        void async_shutdown(NodePrxCallbackPtr callback,const bm::TaskConf &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"shutdown", _os, context, _mStatus, callback);
        }
        
        void coro_shutdown(NodeCoroPrxCallbackPtr callback,const bm::TaskConf &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"shutdown", _os, context, _mStatus, callback, true);
        }

        tars::Int32 startup(const bm::TaskConf & req,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            shared_ptr<tars::ResponsePacket> rep = tars_invoke(tars::TARSNORMAL,"startup", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_startup(NodePrxCallbackPtr callback,const bm::TaskConf &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"startup", _os, context, _mStatus, callback);
        }
        
        void coro_startup(NodeCoroPrxCallbackPtr callback,const bm::TaskConf &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriterVector> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"startup", _os, context, _mStatus, callback, true);
        }

        NodeProxy* tars_hash(int64_t key)
        {
            return (NodeProxy*)ServantProxy::tars_hash(key);
        }

        NodeProxy* tars_consistent_hash(int64_t key)
        {
            return (NodeProxy*)ServantProxy::tars_consistent_hash(key);
        }

        NodeProxy* tars_set_timeout(int msecond)
        {
            return (NodeProxy*)ServantProxy::tars_set_timeout(msecond);
        }

        static const char* tars_prxname() { return "NodeProxy"; }
    };
    typedef tars::TC_AutoPtr<NodeProxy> NodePrx;

    /* servant for server */
    class Node : public tars::Servant
    {
    public:
        virtual ~Node(){}
        virtual tars::Int32 capacity(bm::NodeStat &stats,tars::TarsCurrentPtr current) = 0;
        static void async_response_capacity(tars::TarsCurrentPtr current, tars::Int32 _ret, const bm::NodeStat &stats)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("tars_ret", _ret);
                tarsAttr.put("stats", stats);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["stats"] = tars::JsonOutput::writeJson(stats);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(stats, 1);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 query(const bm::TaskConf & req,bm::QueryRsp &rsp,tars::TarsCurrentPtr current) = 0;
        static void async_response_query(tars::TarsCurrentPtr current, tars::Int32 _ret, const bm::QueryRsp &rsp)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("tars_ret", _ret);
                tarsAttr.put("rsp", rsp);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["rsp"] = tars::JsonOutput::writeJson(rsp);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(rsp, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 shutdown(const bm::TaskConf & req,bm::QueryRsp &rsp,tars::TarsCurrentPtr current) = 0;
        static void async_response_shutdown(tars::TarsCurrentPtr current, tars::Int32 _ret, const bm::QueryRsp &rsp)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("tars_ret", _ret);
                tarsAttr.put("rsp", rsp);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["rsp"] = tars::JsonOutput::writeJson(rsp);
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(rsp, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 startup(const bm::TaskConf & req,tars::TarsCurrentPtr current) = 0;
        static void async_response_startup(tars::TarsCurrentPtr current, tars::Int32 _ret)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("tars_ret", _ret);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else if (current->getRequestVersion() == JSONVERSION)
            {
                tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                vector<char> sJsonResponseBuffer;
                tars::TC_Json::writeValue(_p, sJsonResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sJsonResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriterVector> _os;
                _os.write(_ret, 0);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

    public:
        int onDispatch(tars::TarsCurrentPtr _current, vector<char> &_sResponseBuffer)
        {
            static ::std::string __bm__Node_all[]=
            {
                "capacity",
                "query",
                "shutdown",
                "startup"
            };

            pair<string*, string*> r = equal_range(__bm__Node_all, __bm__Node_all+4, _current->getFuncName());
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __bm__Node_all)
            {
                case 0:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    bm::NodeStat stats;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.getByDefault("stats", stats, stats);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(stats, _jsonPtr->value["stats"], false);
                    }
                    else
                    {
                        _is.read(stats, 1, false);
                    }
                    tars::Int32 _ret = capacity(stats, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("tars_ret", _ret);
                            tarsAttr.put("stats", stats);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["stats"] = tars::JsonOutput::writeJson(stats);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(stats, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    bm::TaskConf req;
                    bm::QueryRsp rsp;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("req", req);
                        tarsAttr.getByDefault("rsp", rsp, rsp);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(req, _jsonPtr->value["req"], true);
                        tars::JsonInput::readJson(rsp, _jsonPtr->value["rsp"], false);
                    }
                    else
                    {
                        _is.read(req, 1, true);
                        _is.read(rsp, 2, false);
                    }
                    tars::Int32 _ret = query(req,rsp, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("tars_ret", _ret);
                            tarsAttr.put("rsp", rsp);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["rsp"] = tars::JsonOutput::writeJson(rsp);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(rsp, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    bm::TaskConf req;
                    bm::QueryRsp rsp;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("req", req);
                        tarsAttr.getByDefault("rsp", rsp, rsp);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(req, _jsonPtr->value["req"], true);
                        tars::JsonInput::readJson(rsp, _jsonPtr->value["rsp"], false);
                    }
                    else
                    {
                        _is.read(req, 1, true);
                        _is.read(rsp, 2, false);
                    }
                    tars::Int32 _ret = shutdown(req,rsp, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("tars_ret", _ret);
                            tarsAttr.put("rsp", rsp);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["rsp"] = tars::JsonOutput::writeJson(rsp);
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(rsp, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    bm::TaskConf req;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("req", req);
                    }
                    else if (_current->getRequestVersion() == JSONVERSION)
                    {
                        tars::JsonValueObjPtr _jsonPtr = tars::JsonValueObjPtr::dynamicCast(tars::TC_Json::getValue(_current->getRequestBuffer()));
                        tars::JsonInput::readJson(req, _jsonPtr->value["req"], true);
                    }
                    else
                    {
                        _is.read(req, 1, true);
                    }
                    tars::Int32 _ret = startup(req, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<tars::BufferWriterVector, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("tars_ret", _ret);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else if (_current->getRequestVersion() == JSONVERSION)
                        {
                            tars::JsonValueObjPtr _p = new tars::JsonValueObj();
                            _p->value["tars_ret"] = tars::JsonOutput::writeJson(_ret);
                            tars::TC_Json::writeValue(_p, _sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }
    };


}



#endif
